(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class;

var _component = require('@reduct/component');

var _nitpick = require('@reduct/nitpick');

var _nitpick2 = _interopRequireDefault(_nitpick);

var _domAddClass = require('dom-add-class');

var _domAddClass2 = _interopRequireDefault(_domAddClass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShowMoreComponent = (_dec = (0, _component.component)({
  maximumHeight: _nitpick2.default.number.isRequired,
  selector: _nitpick2.default.string.isRequired,
  targetClass: _nitpick2.default.string.isRequired,
  buttonClass: _nitpick2.default.string.isRequired,
  wrapperClass: _nitpick2.default.string.isRequired,
  iconClass: _nitpick2.default.string.isRequired
}), _dec(_class = function () {
  _createClass(ShowMoreComponent, [{
    key: 'getDefaultProps',
    value: function getDefaultProps() {
      return {
        maximumHeight: 210,
        wrapperClass: 'show-more',
        targetClass: 'show-more__target',
        buttonClass: 'show-more__button',
        iconClass: 'fa fa-chevron-down'
      };
    }
  }]);

  function ShowMoreComponent() {
    _classCallCheck(this, ShowMoreComponent);

    var _props = this.props;
    var maximumHeight = _props.maximumHeight;
    var selector = _props.selector;

    this.target = this.el.querySelector(selector);
    this.state.isOpen = true;

    if (!this.target) {
      return;
    }

    var offsetHeight = this.target.offsetHeight;


    this.init();
    if (offsetHeight > maximumHeight) {
      this.enable();
    } else {
      this.open();
    }
  }

  _createClass(ShowMoreComponent, [{
    key: 'init',
    value: function init() {
      var _props2 = this.props;
      var wrapperClass = _props2.wrapperClass;
      var targetClass = _props2.targetClass;

      (0, _domAddClass2.default)(this.el, wrapperClass);
      (0, _domAddClass2.default)(this.target, targetClass);
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.close();
      this.appendButton();
    }
  }, {
    key: 'appendButton',
    value: function appendButton() {
      var that = this;
      var button = document.createElement('button');
      var _props3 = this.props;
      var buttonClass = _props3.buttonClass;
      var iconClass = _props3.iconClass;

      (0, _domAddClass2.default)(button, buttonClass);

      var icon = document.createElement('i');
      (0, _domAddClass2.default)(icon, iconClass);

      button.appendChild(icon);
      button.addEventListener('click', function (e) {
        e.preventDefault();
        that.toggle();
      });

      this.el.appendChild(button);
    }
  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.state.isOpen === false) {
        this.open();
      } else {
        this.close();
      }
    }
  }, {
    key: 'close',
    value: function close() {
      this.target.style.maxHeight = this.props.maximumHeight + 'px';
      this.state.isOpen = false;
    }
  }, {
    key: 'open',
    value: function open() {
      this.target.style.maxHeight = '999px';
      this.state.isOpen = true;
    }
  }]);

  return ShowMoreComponent;
}()) || _class);
exports.default = ShowMoreComponent;

},{"@reduct/component":5,"@reduct/nitpick":6,"dom-add-class":7}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ShowMore = undefined;

var _ShowMore = require('./ShowMore.js');

var _ShowMore2 = _interopRequireDefault(_ShowMore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.ShowMore = _ShowMore2.default;

},{"./ShowMore.js":1}],3:[function(require,module,exports){
'use strict';

var _assembler = require('@reduct/assembler');

var _assembler2 = _interopRequireDefault(_assembler);

var _Components = require('./Components/');

var components = _interopRequireWildcard(_Components);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var app = (0, _assembler2.default)();

app.registerAll(components);

setTimeout(function () {
  return app.run();
}, 0);
document.addEventListener('Neos.PageLoaded', app.run());

},{"./Components/":2,"@reduct/assembler":4}],4:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).assembler = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/**
 *
 * @name @reduct/logger
 * @version 1.1.0
 * @license MIT
 *
 * @author Tyll Weiß <inkdpixels@gmail.com>
 * @author André König <andre.koenig@posteo.de>
 * @author Wilhelm Behncke
 *
 */


(function () {
    var reductOpts = {
        isTestingEnv: false,
        packageVersion: {
            major: 1,
            minor: 1,
            patch: 0
        }
    };
    var world = this;

    // Check for globals.
    if (typeof window !== "undefined") {
        world = window;
    } else if (typeof global !== "undefined") {
        world = global;
    } else if (typeof self !== "undefined") {
        world = self;
    }

    // Execute the isTestingEnv check.
    reductOpts.isTestingEnv = world.process && world.process.title && !!~world.process.title.indexOf('reduct');

    return (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.logger = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/*global reductOpts*/

/**
 * @private
 *
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _isNumeric(num) {
    return !isNaN(num);
}

var logLevels = {
    ALL: 2,
    WARNINGS: 1,
    SILENT: 0
};

var Logger = (function () {
    /**
     * Sets up internal properties for the logger.
     *
     * @param namespace {String} The optional namespace for the logger.
     * @param logLevel {Number} The optional initial logLevel for the logger.
     */

    function Logger() {
        var namespace = arguments.length <= 0 || arguments[0] === undefined ? '@reduct/logger' : arguments[0];
        var logLevel = arguments.length <= 1 || arguments[1] === undefined ? logLevels.ALL : arguments[1];

        _classCallCheck(this, Logger);

        this.version = reductOpts.packageVersion;
        this.logLevel = logLevel;
        this.namespace = namespace;

        this.instances = [];
    }

    //
    // Check for the existence of an logger instance in the global namespace,
    // and if none was found create a singleton.
    //

    /**
     * Returns customized version of the logger API.
     *
     * @param namespace {String} The namespace of the new logger instance.
     */

    _createClass(Logger, [{
        key: 'getLogger',
        value: function getLogger() {
            var namespace = arguments.length <= 0 || arguments[0] === undefined ? this.namespace : arguments[0];

            var logger = new Logger(namespace, this.logLevel);

            this.instances.push(logger);

            return {
                log: function log(message, appendix) {
                    logger.log(message, appendix);
                },

                info: function info(message, appendix) {
                    logger.info(message, appendix);
                },

                warn: function warn(message, appendix) {
                    logger.warn(message, appendix);
                },

                error: function error(message, appendix) {
                    logger.error(message, appendix);
                }
            };
        }

        /**
         * Adjusts the noise of the centralized instance of the logger.
         * 0 => No messages are displayed
         * 1 => Only severe messages are displayed
         * 2 => Every message is displayed
         *
         * @param int {Number} The new log level.
         * @returns {Logger}
         *
         */
    }, {
        key: 'setLogLevel',
        value: function setLogLevel(int) {
            var logLevel = _isNumeric(int) ? int : 2;

            this.logLevel = logLevel;

            this.instances.forEach(function (logger) {
                logger.logLevel = logLevel;
            });

            return this;
        }

        /**
         * Logs a message to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'log',
        value: function log(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.ALL) {
                return this;
            }

            try {
                console.log(this.namespace + ': ' + message, appendix);
            } catch (e) {}

            return this;
        }

        /**
         * Logs a info to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the info log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'info',
        value: function info(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.ALL) {
                return this;
            }

            try {
                console.info(this.namespace + ' Info: ' + message, appendix);
            } catch (e) {}

            return this;
        }

        /**
         * Logs a warning to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the warning.
         * @returns {Logger}
         *
         */
    }, {
        key: 'warn',
        value: function warn(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.WARNINGS) {
                return this;
            }

            try {
                console.warn(this.namespace + ' Warning: ' + message, appendix);
            } catch (e) {}
        }

        /**
         * Logs a error to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the error log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'error',
        value: function error(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.SILENT) {
                return this;
            }

            if (appendix !== '') {
                try {
                    // We still need the console.error call since the Error object can't print out references to HTML Elements/Objects etc.
                    console.error(message, appendix);
                } catch (e) {}

                throw new Error(this.namespace + ' Error: Details are posted above.');
            } else {
                throw new Error(this.namespace + ' Error: ' + message);
            }
        }
    }]);

    return Logger;
})();

if (!(global.reductLogger instanceof Logger)) {
    var logger = new Logger();

    //
    // Reduce the logging noise for the unit tests.
    //
    if (reductOpts.isTestingEnv) {
        logger.setLogLevel(0);
    }

    global.reductLogger = logger;
}

exports['default'] = {
    logger: global.reductLogger,
    logLevels: logLevels
};
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});
}());
                
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(_dereq_,module,exports){
(function (process){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _logger = _dereq_('@reduct/logger');

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assemblerLogger = _logger.logger.getLogger('@reduct/assembler');

/**
 * The Assembler.
 *
 * An assembler instance acts as the central point of your
 * application. It is responsible for connecting DOM nodes with
 * actual component instances through exposed interfaces. Those
 * interfaces provides the functionality for registering component
 * classes and bootstrapping the whole application.
 *
 * Usage example:
 *
 *	 import assembler from 'assembler';
 *
 *	 // Importing your actual components
 *	 import MyComponent from 'my-component';
 *	 import AnotherComponent from 'another-component';
 *
 *	 const app = assembler();
 *
 *	 app.register(MyComponent);
 *	 app.register(AnotherComponent, 'NewsComponent');
 *
 *	 // Start the application (will parse the DOM and mount the
 *	 // component instances).
 *	 app.run();
 *
 */

var Assembler = (function () {

	/**
  * Initializes the empty component class index
  * and the actual component instance cache.
  *
  * @param {object} opts Overwritten default options
  *
  */

	function Assembler() {
		var opts = arguments.length <= 0 || arguments[0] === undefined ? { marker: 'component' } : arguments[0];

		_classCallCheck(this, Assembler);

		this.marker = opts.marker;
		this.selector = 'data-' + this.marker;

		this.index = {};

		//
		// The actual instantiated components.
		//
		// Structure:
		//
		//	 {
		//		 'ComponentClassName': [object, object],
		//		 'YetAnotherComponentClassName': [object]
		//	 }
		//
		this.components = {};

		//
		// A cache of DOM elements.
		//
		// This is for checking if a component has already been instantiated.
		//
		// TODO: Refactoring: Find another way (with good performance) to combine this
		// array with the `components` object.
		//
		this.elements = [];
	}

	/**
 * @private
 *
 * Parses the function name out of `Function.prototype.toString()`.
 *
 * TODO: Move into Utilities when supported by `build-tools`.
 *
 * @param {Function} The function from which the name should be extracted.
 * @returns {string} The actual name (`anonymous` when the function does not provide a name).
 *
 */

	_createClass(Assembler, [{
		key: 'getFunctionName',
		value: function getFunctionName(fn) {
			if (Reflect.apply(Object.prototype.toString, fn, fn) !== '[object Function]') {
				assemblerLogger.error(fn + ' is not a valid function.');
			}

			var regexe = /^\s*function\s*([^\(]*)/im;

			return fn.name || regexe.exec(fn.toString())[1] || 'anonymous';
		}

		/**
   * @private
   *
   * Checks if a component has already been instantiated.
   *
   * @param {DOMElement} element The element which should be connected to a component.
   *
   * @returns {boolean}
   *
   */

	}, {
		key: 'isInstantiated',
		value: function isInstantiated(element) {
			return this.elements.indexOf(element) !== -1;
		}

		/**
   * @private
   *
   * Instantiates a component by a given DOM node.
   *
   * Will extract the component's name out of the DOM nodes `data`
   * attribute, instantiates the actual component object and pushes
   * the instance to the internal `components` index.
   *
   * @param {HTMLElement} element The component's root DOM node.
   *
   */

	}, {
		key: 'instantiate',
		value: function instantiate(element) {
			if (!this.isInstantiated(element)) {
				var name = element.getAttribute(this.selector);
				var instantiatedTargets = this.components[name] || [];

				var components = this.components[name] = Reflect.apply(Array.prototype.slice, instantiatedTargets, instantiatedTargets);
				var Component = this.index[name];

				this.elements.unshift(element);

				components.unshift(new Component(element));
			}
		}

		/**
   * Registers a component class.
   *
   * Usage example
   *
   *	 app.register(MyComponent); // Name: 'MyComponent'
   *
   *	 app.register(MyComponent, 'FooComponent'); // Name: 'FooComponent'
   *
   * @param {Function} ComponentClass The component class which should be registered.
   * @param {string} name An alternative name (optional)
   *
   */

	}, {
		key: 'register',
		value: function register(ComponentClass, name) {
			var type = typeof ComponentClass === 'undefined' ? 'undefined' : _typeof(ComponentClass);

			if (type !== 'function') {
				throw new Error('\'' + type + '\' is not a valid component class.');
			}

			name = name || this.getFunctionName(ComponentClass);

			this.index[name] = ComponentClass;

			return this;
		}

		/**
   * Takes a hashmap with multiple component classes
   * and registers them at once.
   *
   * Usage example:
   *
   *	 app.registerAll({
   *		 MyComponent: MyComponent,		// name: 'MyComponent'
   *		 'AnotherComponent': FooComponent // name: 'AnotherComponent'
   *	 });
   *
   *	 // With destructuring
   *	 app.registerAll({MyComponent, FooComponent});
   *
   * @param {object} classMap A map with multiple component classes.
   *
   */

	}, {
		key: 'registerAll',
		value: function registerAll(classMap) {
			var _this = this;

			Object.keys(classMap).forEach(function (name) {
				return _this.register(classMap[name], name);
			});

			return this;
		}

		/**
   * "Parse" the DOM for component declarations and
   * instantiate the actual, well, components.
   *
   */

	}, {
		key: 'run',
		value: function run() {
			var _this2 = this;

			var nodeList = document.querySelectorAll('[' + this.selector + ']');
			var elements = Reflect.apply(Array.prototype.slice, nodeList, [nodeList]);
			var names = Object.keys(this.index);

			//
			// Find all instantiable elements.
			// Note: `getAttribute` has to be used due to: https://github.com/tmpvar/jsdom/issues/961
			//
			elements.filter(function (element) {
				return names.indexOf(element.getAttribute(_this2.selector)) !== -1;
			}).forEach(function (element) {
				return _this2.instantiate(element);
			});
		}
	}]);

	return Assembler;
})();

//
// Create the `assembler` factory function.
// This factory will create a new instance of the `assembler` and exposes the API
//

var assembler = function assembler(opts) {
	var assembler = new Assembler(opts);

	//
	// Shard the actual front-facing API (for not leaking private methods and properties).
	//
	var api = {
		register: function register(ComponentClass, name) {
			return assembler.register(ComponentClass, name);
		},
		registerAll: function registerAll(classMap) {
			return assembler.registerAll(classMap);
		},
		run: function run() {
			return assembler.run();
		}
	};

	//
	// Expose additional attributes for the tests.
	//
	try {
		if (process.env.TEST) {
			api.index = assembler.index;
			api.components = assembler.components;
		}
	} catch (e) {}

	return api;
};

exports.default = assembler;

}).call(this,_dereq_('_process'))
},{"@reduct/logger":1,"_process":2}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).Component = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).loggerPackage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(_dereq_,module,exports){
(function (process,global){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 *
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function _isNumeric(num) {
	return !isNaN(num);
}

var logLevels = {
	ALL: 2,
	WARNINGS: 1,
	SILENT: 0
};

var Logger = (function () {
	/**
  * Sets up internal properties for the logger.
  *
  * @param namespace {String} The optional namespace for the logger.
  * @param logLevel {Number} The optional initial logLevel for the logger.
  */

	function Logger() {
		var namespace = arguments.length <= 0 || arguments[0] === undefined ? '@reduct/logger' : arguments[0];
		var logLevel = arguments.length <= 1 || arguments[1] === undefined ? logLevels.ALL : arguments[1];

		_classCallCheck(this, Logger);

		this.logLevel = logLevel;
		this.namespace = namespace;

		this.instances = [];
	}

	/**
  * Returns customized version of the logger API.
  *
  * @param namespace {String} The namespace of the new logger instance.
  */

	_createClass(Logger, [{
		key: 'getLogger',
		value: function getLogger() {
			var namespace = arguments.length <= 0 || arguments[0] === undefined ? this.namespace : arguments[0];

			var logger = new Logger(namespace, this.logLevel);

			this.instances.push(logger);

			return {
				log: function log(message, appendix) {
					logger.log(message, appendix);
				},

				info: function info(message, appendix) {
					logger.info(message, appendix);
				},

				warn: function warn(message, appendix) {
					logger.warn(message, appendix);
				},

				error: function error(message, appendix) {
					logger.error(message, appendix);
				}
			};
		}

		/**
   * Adjusts the noise of the centralized instance of the logger.
   * 0 => No messages are displayed
   * 1 => Only severe messages are displayed
   * 2 => Every message is displayed
   *
   * @param int {Number} The new log level.
   * @returns {Logger}
   *
   */

	}, {
		key: 'setLogLevel',
		value: function setLogLevel(int) {
			var logLevel = _isNumeric(int) ? int : 2;

			this.logLevel = logLevel;

			this.instances.forEach(function (logger) {
				logger.logLevel = logLevel;
			});

			return this;
		}

		/**
   * Logs a message to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'log',
		value: function log(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.ALL) {
				return this;
			}

			try {
				console.log(this.namespace + ': ' + message, appendix);
			} catch (e) {}

			return this;
		}

		/**
   * Logs a info to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the info log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'info',
		value: function info(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.ALL) {
				return this;
			}

			try {
				console.info(this.namespace + ' Info: ' + message, appendix);
			} catch (e) {}

			return this;
		}

		/**
   * Logs a warning to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the warning.
   * @returns {Logger}
   *
   */

	}, {
		key: 'warn',
		value: function warn(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.WARNINGS) {
				return this;
			}

			try {
				console.warn(this.namespace + ' Warning: ' + message, appendix);
			} catch (e) {}
		}

		/**
   * Logs a error to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the error log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'error',
		value: function error(message, appendix) {
			if (this.logLevel < logLevels.SILENT) {
				return this;
			}

			if (appendix) {
				try {
					// We still need the console.error call since the Error object can't print out references to HTML Elements/Objects etc.
					console.error(message, appendix);
				} catch (e) {}

				throw new Error(this.namespace + ' Error: Details are posted above.');
			} else {
				throw new Error(this.namespace + ' Error: ' + message);
			}
		}
	}]);

	return Logger;
})();

//
// Check for the existence of the global reduct object,
// this is duplicate code, but we can't access it otherwise
// since the browserify initialization hooks in later and only in module-system free environments.
//

if (!global.reduct) {
	global.reduct = {};
}

//
// Check for the existence of an logger instance in the global namespace,
// and if none was found create a singleton.
//
if (!(global.reduct.logger instanceof Logger)) {
	var _logger = new Logger();

	//
	// Reduce the logging noise for the unit tests.
	//
	try {
		if (process.env.TEST) {
			_logger.setLogLevel(logLevels.SILENT);
		}
	} catch (e) {}

	global.reduct.logger = _logger;
}

var logger = global.reduct.logger;

exports.logger = logger;
exports.logLevels = logLevels;

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":1}]},{},[2])(2)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":2}],2:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.component = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _logger = _dereq_('@reduct/logger');

var _utilities = _dereq_('./utilities/');

var _messages = _dereq_('./messages.js');

var messages = _interopRequireWildcard(_messages);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

console.log(_utilities.prototype);
var componentLogger = _logger.logger.getLogger('@reduct/component');
var extractFrom = _utilities.prototype.extractFrom;
var injectInto = _utilities.prototype.injectInto;

/**
 * Helper function to move passed props via constructor into the component
 * instance and validate them along the way.
 *
 * @param {Function} context The component instance.
 * @param {Object} passedProps An optional props object which can be directly passed to the class.
 * @returns {Void}
 */

function _validateAndSetProps(context, passedProps) {
	var el = context.el;
	var getDefaultProps = context.getDefaultProps;

	var defaultProps = getDefaultProps();
	var propTypes = context.constructor.propTypes || {};
	var componentName = context.constructor.name;
	var propNames = Object.keys(propTypes);
	var props = {};

	if (!(0, _utilities.isObject)(defaultProps)) {
		_logger.logger.error('The getDefaultProps() method of Component "' + componentName + '" did not return a valid Object. This can lead to unexpected behavior and Errors.');
	}

	//
	// First of, we need to aggregate all props, either from the passed props, the dom or the getDefaultProps() method.
	//
	propNames.forEach(function (propName) {
		var value = passedProps[propName] || el.getAttribute('data-' + propName.toLowerCase()) || defaultProps[propName];

		props[propName] = value;
	});

	//
	// After the aggregation is done, we validate the generated props object with each propType validator.
	// If the user passed an object containing a `isOptional` function as the propType, we map the propType to the function.
	// This reduces the overal code needed to defined propTypes and increases similarity with Reacts syntax.
	//
	propNames.forEach(function (propName) {
		var propTypeTarget = propTypes[propName];
		var propType = (0, _utilities.isObject)(propTypeTarget) && (0, _utilities.isFunction)(propTypeTarget.isOptional) ? propTypeTarget.isOptional : propTypeTarget;
		var isPropTypeInvalid = !(0, _utilities.isFunction)(propType);

		if (isPropTypeInvalid) {
			_logger.logger.error('Invalid propType "' + propName + '" specified in Component "' + componentName + '". Please specify a function as the propType validator.');
		}

		var propTypeResult = propType(props, propName, componentName);

		if ((0, _utilities.isError)(propTypeResult)) {
			_logger.logger.error('The propType for "' + propName + '" in Component "' + componentName + '" returned an Error with the message:\n\n"' + propTypeResult.message + '".');
		}

		//
		// If no error was thrown, and the propType has returned a transformed value,
		// which is not `null` or `undefined`, overwrite the aggregated value.
		//
		if ((0, _utilities.isDefined)(propTypeResult)) {
			props[propName] = propTypeResult;
		}
	});

	// Freeze the props object to avoid further editing off the object.
	context.props = Object.freeze(props);
}

/**
 * Helper function to set initial state variables in the component
 * instance.
 *
 * @param {Function} context The component instance.
 * @returns {Void}
 */
function _setInitialStates(context) {
	var initialState = context.getInitialState();

	if ((0, _utilities.isObject)(initialState)) {
		context.initialStateKeys = Object.keys(initialState);
		context.setState(initialState);
	} else {
		componentLogger.warn('Please return a valid object in the getInitialState() method of "' + context.constructor.name + '".');
	}
}

var ComponentClass = function () {
	function ComponentClass(element, props) {
		_classCallCheck(this, ComponentClass);

		// Fail-Safe mechanism if someone is passing an array or the like as a second argument.
		props = (0, _utilities.isObject)(props) ? props : {};

		if (!(0, _utilities.isDefined)(element)) {
			componentLogger.warn(messages.noElement);
		}

		// The element property for the getElement() method.
		this.el = element || global.document.createElement('div');

		// Holds all props.
		this.props = {};

		// Holds the components state.
		this.state = {};

		// Holds all event listeners.
		this.observers = {};

		// Cache for not hitting the DOM over and over again in the `find` and `findOne` methods.
		this.queryCache = {};

		// Holds all keys of the initial state, used to check for the initial existence of state additions.
		this.initialStateKeys = [];

		// Set the props and the initial state of the component.
		_validateAndSetProps(this, props);
		_setInitialStates(this);
	}

	/**
  * Returns the HTML Element on which the Component was mounted upon.
  *
  * @returns {HTMLElement}
  *
  */


	_createClass(ComponentClass, [{
		key: 'getElement',
		value: function getElement() {
			return this.el;
		}

		/**
   * Returns the next found child node by a given selector.
   *
   * @returns {HTMLElement}
   *
   */

	}, {
		key: 'find',
		value: function find(selector) {
			return this.findAll(selector).shift();
		}

		/**
   * Returns all found child nodes by a given selector.
   *
   * @returns {Array<HTMLElement>}
   *
   */

	}, {
		key: 'findAll',
		value: function findAll(selector) {
			var cachedResult = this.queryCache[selector];

			if (cachedResult) {
				return cachedResult;
			}

			var nodeList = this.getElement().querySelectorAll(selector);
			var nodes = Reflect.apply(Array.prototype.slice, nodeList, [nodeList]);

			this.queryCache[selector] = [].concat(_toConsumableArray(nodes));

			return nodes;
		}

		/**
   * The default method which declares the default properties of the Component.
   *
   * @returns {Object} The object containing default props.
   *
   */

	}, {
		key: 'getDefaultProps',
		value: function getDefaultProps() {
			return {};
		}

		/**
   * Returns a boolean regarding the existence of the property.
   *
   * @param propName {String} The name of the property.
   * @returns {boolean} The result of the check.
   *
   */

	}, {
		key: 'hasProp',
		value: function hasProp(propName) {
			return (0, _utilities.isDefined)(this.props[propName]);
		}

		/**
   * The default method which declares the default state of the Component.
   *
   * @returns {Object} The object containing default state.
   *
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			return {};
		}

		/**
   * Sets all differing state key/value pairs to the Components state.
   *
   * @param delta {Object} The diff object which holds all state changes for the component.
   * @param opts {Object} Optional options object which f.e. could turn off state events from firing.
   */

	}, {
		key: 'setState',
		value: function setState() {
			var delta = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
			var opts = arguments.length <= 1 || arguments[1] === undefined ? { silent: false } : arguments[1];

			var isNotSilent = !opts.silent;
			var previousState = (0, _utilities.cloneObject)(this.state);
			var initialStateKeys = this.initialStateKeys;


			for (var key in delta) {
				if (delta.hasOwnProperty(key)) {
					var newValue = delta[key];
					var oldValue = previousState[key];

					if (initialStateKeys.indexOf(key) === -1) {
						componentLogger.error('Please specify an initial value for \'' + key + '\' in your getInitialState() method of "' + this.constructor.name + '".');
					} else if (newValue !== oldValue) {
						this.state[key] = newValue;

						if (isNotSilent) {
							this.trigger('change:' + key, {
								key: key,
								value: newValue,
								previousValue: oldValue
							});
						}
					}
				}
			}

			// Trigger event
			if (isNotSilent) {
				this.trigger('change', {
					delta: delta,
					previousState: previousState
				});
			}
		}

		/**
   * Declares a event listener on the given event name.
   *
   * @param event {String} The name of the event under which the listener will be saved under.
   * @param listener {Function} The listener which will be executed once the event will be fired.
   * @returns {Number} The length of the event listener array.
   *
   */

	}, {
		key: 'on',
		value: function on(event, listener) {
			var targetArray = this.observers[event] || (this.observers[event] = []);

			return targetArray.push(listener);
		}

		/**
   * Triggers the event of the given name with optional data.
   *
   * @todo Support for multiple arguments.
   * @param event {String} The name of the event to trigger.
   * @param data {*} The data to pass to all listeners.
   *
   */

	}, {
		key: 'trigger',
		value: function trigger(event, data) {
			var value = undefined;
			var key = undefined;

			for (value = this.observers[event], key = 0; value && key < value.length;) {
				value[key++](data);
			}
		}

		/**
   * Removes the given listener function from the event of the given name.
   * @param event {String} Name of the event.
   * @param listener {Function} The listener function to remove.
   */

	}, {
		key: 'off',
		value: function off(event, listener) {
			var value = undefined;
			var key = undefined;

			for (value = this.observers[event] || []; listener && (key = value.indexOf(listener)) > -1;) {
				value.splice(key, 1);
			}

			this.observers[event] = listener ? value : [];
		}
	}]);

	return ComponentClass;
}();

//
// First, we export the named `@component` decorator, for simplified usage.
//


var component = exports.component = function component(decoratorPropTypes) {
	return function (CustomComponent) {
		var prototype = extractFrom(CustomComponent);
		var propTypes = decoratorPropTypes || CustomComponent.propTypes;

		return function Wrapper(el, props) {
			var BaseComponent = ComponentClass;

			//
			// Since the base class gets executed first, we need to transfer / reset the
			// getDefaultProps() and getInitialState() method.
			//
			if (prototype.getDefaultProps) {
				BaseComponent.prototype.getDefaultProps = prototype.getDefaultProps;
			} else {
				BaseComponent.prototype.getDefaultProps = ComponentClass.prototype.getDefaultProps;
			}
			if (prototype.getInitialState) {
				BaseComponent.prototype.getInitialState = prototype.getInitialState;
			} else {
				BaseComponent.prototype.getInitialState = ComponentClass.prototype.getInitialState;
			}

			//
			// Create an instance of the component.
			//
			BaseComponent.propTypes = propTypes;
			var base = new BaseComponent(el, props);
			BaseComponent.propTypes = {};

			//
			// Adjust the prototype of the actual component.
			//
			CustomComponent.prototype = base;

			//
			// Inject the prototype of the `CustomComponent`. This will
			// merge the attributes and the methods of the `CustomComponent`
			// with those from `@reduct/component`.
			//
			injectInto(CustomComponent, prototype);

			return new CustomComponent();
		};
	};
};

//
// And the ES6 class as the default export for users who would like to use it the traditional way.
//
exports.default = ComponentClass;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./messages.js":4,"./utilities/":6,"@reduct/logger":1}],4:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var noElement = exports.noElement = 'No element was specified while creating a instance of a Class. Creating a detached DOM Element instead.';
var extendDeprecate = exports.extendDeprecate = '@reduct/component.extend() is deprecated since v1.0.7 - Use the native ES6 extend instead.';

},{}],5:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.cloneObject = cloneObject;
/**
 * Deep-Clones a object.
 *
 * @param obj {Object} The object to clone.
 * @returns {Object} The cloned object.
 */
function cloneObject() {
	var obj = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var target = {};

	for (var i in obj) {
		if (obj.hasOwnProperty(i)) {
			target[i] = obj[i];
		}
	}

	return target;
}

},{}],6:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.prototype = exports.isFunction = exports.isObject = exports.isError = exports.isDefined = exports.cloneObject = undefined;

var _cloneObject = _dereq_('./cloneObject.js');

var _isDefined = _dereq_('./isDefined.js');

var _isError = _dereq_('./isError.js');

var _isObject = _dereq_('./isObject.js');

var _isFunction = _dereq_('./isFunction.js');

var _prototype = _dereq_('./prototype.js');

exports.cloneObject = _cloneObject.cloneObject;
exports.isDefined = _isDefined.isDefined;
exports.isError = _isError.isError;
exports.isObject = _isObject.isObject;
exports.isFunction = _isFunction.isFunction;
exports.prototype = _prototype.prototype;

},{"./cloneObject.js":5,"./isDefined.js":7,"./isError.js":8,"./isFunction.js":9,"./isObject.js":10,"./prototype.js":11}],7:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDefined = isDefined;
/**
 * Checks if the given argument is defined and not `null`.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isDefined(val) {
  return val !== null && val !== undefined;
}

},{}],8:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isError = isError;
/**
 * Checks if the given argument is an instance of the Error Object.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isError(val) {
  return val instanceof Error;
}

},{}],9:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;
/**
 * Checks if the given argument is a function.
 *
 * @param func {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isFunction(func) {
  return typeof func === 'function';
}

},{}],10:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isObject = isObject;
/**
 * Checks if the given argument is a object.
 *
 * @param obj {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj !== 'function' && obj !== null;
}

},{}],11:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var prototype = exports.prototype = {
	extractFrom: function extractFrom(Target) {
		var prototype = {};

		Reflect.ownKeys(Target.prototype).forEach(function (key) {
			if (key !== 'constructor') {
				prototype[key] = Target.prototype[key];
			}
		});

		return prototype;
	},
	injectInto: function injectInto(Target, prototype) {
		for (var key in prototype) {
			if (prototype.hasOwnProperty(key)) {
				Target.prototype[key] = prototype[key];
			}
		}
	}
};

},{}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).nitpick = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies a general check for the existence of a value.
 *
 * @param fn {*} The optional validator function which will be executed after the check.
 * @returns {Function} The curry function which will be wrapped around the validator.
 *
 */

exports.default = function (fn) {
	return (0, _abstractValidator2.default)(function (val) {
		var isValueDefined = (0, _utilities.isDefined)(val);

		if (!isValueDefined) {
			return new Error('The value is required but is either "undefined" or "null".');
		}

		return (0, _utilities.isFunction)(fn) ? fn(val) : val;
	});
};

},{"./abstractValidator.js":2,"./utilities/":12}],2:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Reduces the overall amount of code to align the @reduct/nitpick validators to the validator scheme.
 *
 * @param fn {*} The validator function which will be executed via FP.
 * @returns {Function} The curry function which will be wrapped around the validator.
 *
 */

exports.default = function (fn) {
  return function (props, propName) {
    return fn(props[propName]);
  };
};

},{}],3:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOptional = exports.isRequired = undefined;

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents a general required check against a value.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)();

/**
 * Represents a general optional check against a value.
 *
 * @param val {*} The value which will be validated.
 * @returns {*} Either an undefined or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
  var isValueDefined = (0, _utilities.isDefined)(val);

  // Fail safe to have a conssitent return value
  // if "null" was passed as the value.
  if (!isValueDefined) {
    return undefined;
  }

  return val;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./utilities/":12}],4:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var convertedBoolean = (0, _utilities.convertStringBoolean)(val);
	var isValueNotBool = !(0, _utilities.isBoolean)(convertedBoolean);

	if (isValueNotBool) {
		return new Error('The value is required and must be a "Boolean", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedBoolean;
});

/**
 * Extends the general optional validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var convertedBoolean = (0, _utilities.convertStringBoolean)(val);
	var isValueNotBool = !(0, _utilities.isBoolean)(convertedBoolean);

	if ((0, _utilities.isDefined)(val) && isValueNotBool) {
		return new Error('The value is optional, but must be a "Boolean", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedBoolean;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],5:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

var _bool = _dereq_('./bool.js');

var bool = _interopRequireWildcard(_bool);

var _number = _dereq_('./number.js');

var number = _interopRequireWildcard(_number);

var _object = _dereq_('./object.js');

var object = _interopRequireWildcard(_object);

var _string = _dereq_('./string.js');

var string = _interopRequireWildcard(_string);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
	any: any,
	bool: bool,
	number: number,
	object: object,
	string: string
};

},{"./any.js":3,"./bool.js":4,"./number.js":6,"./object.js":7,"./string.js":8}],6:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Number`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value if it is a valid Boolean.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var convertedNumber = (0, _utilities.isString)(val) ? Math.abs(val) : val;
	var isNumber = (0, _utilities.isNumeric)(convertedNumber);

	if (!isNumber) {
		return new Error('The value is required and must be a "Number", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedNumber;
});

/**
 * Extends the general optional validator for the type `Number`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var convertedNumber = (0, _utilities.isString)(val) ? Math.abs(val) : val;
	var isValueNotNumeric = !(0, _utilities.isNumeric)(convertedNumber);

	if ((0, _utilities.isDefined)(val) && isValueNotNumeric) {
		return new Error('The value is optional, but must be a "Number", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedNumber;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],7:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Object`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	// Try to convert the value to a JSON object.
	try {
		val = JSON.parse(val);
	} catch (e) {}

	if (!(0, _utilities.isObject)(val)) {
		return new Error('The value is required and must be a "Object", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

/**
 * Extends the general optional validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	// Try to convert the value to a JSON object.
	try {
		val = JSON.parse(val);
	} catch (e) {}

	if ((0, _utilities.isDefined)(val) && !(0, _utilities.isObject)(val)) {
		return new Error('The value is optional, but must be a "Object", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],8:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `String`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var isValueNotValidString = !(0, _utilities.isString)(val);

	if (isValueNotValidString) {
		return new Error('The value is required and must be a "String", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

/**
 * Extends the general optional validator for the type `String`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var isValueNoString = !(0, _utilities.isString)(val);

	if ((0, _utilities.isDefined)(val) && isValueNoString) {
		return new Error('The value is optional, but must be a "String", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return (0, _utilities.isDefined)(val) ? val : undefined;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],9:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combinePropTypes = undefined;

var _isError = _dereq_('./isError');

/**
 * Combines several propTypes. The first one that returns an error will
 * end the execution chain.
 *
 * @param ...propTypes {...Function} The propTypes that will be combined
 * @returns {Function}
 *
 */
var combinePropTypes = exports.combinePropTypes = function combinePropTypes() {
  for (var _len = arguments.length, propTypes = Array(_len), _key = 0; _key < _len; _key++) {
    propTypes[_key] = arguments[_key];
  }

  return function (props, propName) {
    for (var i = 0, len = propTypes.length - 1; i < len; i++) {
      var validationResult = propTypes[i](props, propName);
      if ((0, _isError.isError)(validationResult)) {
        return validationResult;
      }
    }

    return propTypes[propTypes.length - 1](props, propName);
  };
};

},{"./isError":16}],10:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Compose various functions.
 *
 * @param ...funcs {...Function} The functions that will be composed
 * @returns {Function}
 *
 */
var compose = exports.compose = function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reverse().reduce(function (currentValue, nextFunction) {
      return nextFunction(currentValue);
    }, arg);
  };
};

},{}],11:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.convertStringBoolean = convertStringBoolean;
/**
 * Converts a string containing a boolean to a real boolean if necessary.
 *
 * @param val
 * @returns {*}
 *
 */
function convertStringBoolean(val) {
	if (val === 'false') {
		val = false;
	}

	if (val === 'true') {
		val = true;
	}

	return val;
}

},{}],12:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isString = exports.isObject = exports.isNumeric = exports.isFunction = exports.isError = exports.isDefined = exports.isBoolean = exports.isArray = exports.convertStringBoolean = exports.compose = exports.combinePropTypes = undefined;

var _combinePropTypes = _dereq_('./combinePropTypes.js');

var _compose = _dereq_('./compose.js');

var _convertStringBoolean = _dereq_('./convertStringBoolean.js');

var _isArray = _dereq_('./isArray.js');

var _isBoolean = _dereq_('./isBoolean.js');

var _isDefined = _dereq_('./isDefined.js');

var _isError = _dereq_('./isError.js');

var _isFunction = _dereq_('./isFunction.js');

var _isNumeric = _dereq_('./isNumeric.js');

var _isObject = _dereq_('./isObject.js');

var _isString = _dereq_('./isString.js');

exports.combinePropTypes = _combinePropTypes.combinePropTypes;
exports.compose = _compose.compose;
exports.convertStringBoolean = _convertStringBoolean.convertStringBoolean;
exports.isArray = _isArray.isArray;
exports.isBoolean = _isBoolean.isBoolean;
exports.isDefined = _isDefined.isDefined;
exports.isError = _isError.isError;
exports.isFunction = _isFunction.isFunction;
exports.isNumeric = _isNumeric.isNumeric;
exports.isObject = _isObject.isObject;
exports.isString = _isString.isString;

},{"./combinePropTypes.js":9,"./compose.js":10,"./convertStringBoolean.js":11,"./isArray.js":13,"./isBoolean.js":14,"./isDefined.js":15,"./isError.js":16,"./isFunction.js":17,"./isNumeric.js":18,"./isObject.js":19,"./isString.js":20}],13:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isArray = isArray;
/**
 * Checks if the given argument is an array.
 *
 * @param arr {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isArray(arr) {
  return arr !== null && (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Array.isArray(arr);
}

},{}],14:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBoolean = isBoolean;
/**
 * Checks if the given argument is a boolean or a string containing a boolean.
 *
 * @param bol {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isBoolean(bol) {
  return typeof bol === 'boolean' || bol === 'true' || bol === 'false';
}

},{}],15:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDefined = isDefined;
/**
 * Checks if the given argument is defined and not `null`.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isDefined(val) {
  return val !== null && val !== undefined;
}

},{}],16:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isError = isError;
/**
 * Checks if the given argument is an instance of the Error Object.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isError(val) {
  return val instanceof Error;
}

},{}],17:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;
/**
 * Checks if the given argument is a function.
 *
 * @param func {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isFunction(func) {
  return typeof func === 'function';
}

},{}],18:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumeric = isNumeric;
/**
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isNumeric(num) {
  return !isNaN(num) && num !== null && num !== true && num !== false;
}

},{}],19:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isObject = isObject;
/**
 * Checks if the given argument is a object.
 *
 * @param obj {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
}

},{}],20:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isString = isString;
/**
 * Checks if the given argument is a string.
 *
 * @param str {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isString(str) {
  return typeof str === 'string';
}

},{}]},{},[5])(5)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
function getClassesNotInElement( el, cssClasses ) {
  var classes = el.className.split( /\s+/ ).reduce( function ( seq, current ) {
    seq[ current ] = true;
    return seq;
  }, { } );

  return cssClasses.filter( function ( klass ) {
    return !classes[ klass ];
  } );
}

module.exports = function () {
  var args = [ ].slice.call( arguments );
  var elements = args.shift();

  if ( !Array.isArray( elements ) ) {
    elements = [ elements ];
  }

  args = args.reduce( function ( seq, cName ) {
    if ( typeof cName !== 'string' ) {
      throw new Error( 'addClass expects a string' );
    }
    cName = cName.trim();
    if ( cName ) {
      seq = seq.concat( cName.split( /\s+/ ) );
    }
    return seq;
  }, [ ] );

  elements.forEach( function ( el ) {
    if ( el.classList ) {
      args.forEach( function ( cName ) {
        el.classList.add( cName );
      } );

    } else {
      args = getClassesNotInElement( el, args );
      if ( args.length > 0 ) {
        var className = args.join( ' ' );
        el.className += ' ' + className;
      }
    }
  } );
};

},{}]},{},[3]);
